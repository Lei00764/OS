- Which registers contain arguments to functions? For example, which register holds 13 in main's call to printf?

前 8 个参数会放置在 a0-a7 寄存器，13 被放在寄存器 a2

void main(void) {
  1c:	1101                	addi	sp,sp,-32
  1e:	ec06                	sd	ra,24(sp)
  20:	e822                	sd	s0,16(sp)
  22:	1000                	addi	s0,sp,32
  printf("%d %d\n", f(8)+1, 13);
  24:	4635                	li	a2,13
  26:	45b1                	li	a1,12
  28:	00000517          	auipc	a0,0x0
  2c:	7f850513          	addi	a0,a0,2040 # 820 <malloc+0xea>
  30:	00000097          	auipc	ra,0x0
  34:	648080e7          	jalr	1608(ra) # 678 <printf>
}

- Where is the call to function f in the assembly code for main? Where is the call to g? (Hint: the compiler may inline functions.)

没有这样的代码，main 函数直接得到 12，然后再放到 a1 寄存器中

- At what address is the function printf located?

0x0000000000000630

- What value is in the register ra just after the jalr to printf in main?

  34:	600080e7          	jalr	1536(ra) # 630 <printf>

  ra：执行完 print 函数后下一条执行地址，即 0x38

- Run the following code.
	unsigned int i = 0x00646c72;
	printf("H%x Wo%s", 57616, &i);
What is the output? Here's an ASCII table that maps bytes to characters.
The output depends on that fact that the RISC-V is little-endian. If the RISC-V were instead big-endian what would you set i to in order to yield the same output? Would you need to change 57616 to a different value?
Here's a description of little- and big-endian and a more whimsical description.

小端：HE110 World （低字节放低地址）
如果是大端，将 i 改成 0x726c6400，57616 不需要变
%x 和 %s 的区别
%x 就不变
%s 要考虑大小端的影响

In the following code, what is going to be printed after 'y='? (note: the answer is not a specific value.) Why does this happen?
	printf("x=%d y=%d", 3);

x = 3 y = 5221（不确定的值）